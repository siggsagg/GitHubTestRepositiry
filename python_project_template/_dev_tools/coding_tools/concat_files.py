"""Path: _dev_tools/coding_tools/concat_files.py."""
import os
import subprocess
import sys

# --- Configuration ---
PROJECT_ROOT_NAME = "python_project_template"
OUTPUT_FILENAME = "concatenated_code.py" # To be placed in the project root
DIRS_TO_SCAN_RELATIVE = ["src", "utils"] # Directories within project root to scan for .py files
FILE_TREE_SCRIPT_NAME = "create_path_tree.py" # Assumed to be in the same dir as this script
FILE_TREE_TXT_NAME = "file_path_tree.txt" # Expected in the project root

# --- Path Setup ---
try:
    CURRENT_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
    # Project root is two levels up from _dev_tools/coding_tools/
    PROJECT_ROOT_ABS_PATH = os.path.abspath(os.path.join(CURRENT_SCRIPT_DIR, "..", ".."))

    if not PROJECT_ROOT_ABS_PATH.endswith(PROJECT_ROOT_NAME):
        raise RuntimeError(f"Calculated project root '{PROJECT_ROOT_ABS_PATH}' does not end with expected name '{PROJECT_ROOT_NAME}'.")

    OUTPUT_FILE_ABS_PATH = os.path.join(PROJECT_ROOT_ABS_PATH, OUTPUT_FILENAME)
    FILE_TREE_SCRIPT_ABS_PATH = os.path.join(CURRENT_SCRIPT_DIR, FILE_TREE_SCRIPT_NAME)
    FILE_TREE_TXT_ABS_PATH = os.path.join(PROJECT_ROOT_ABS_PATH, FILE_TREE_TXT_NAME)
    DIRS_TO_SCAN_ABS = [os.path.join(PROJECT_ROOT_ABS_PATH, d) for d in DIRS_TO_SCAN_RELATIVE]

except Exception as e:
    print(f"Error during path setup: {e}", file=sys.stderr)
    sys.exit(1)

def update_file_tree():
    """
    Runs the create_path_tree.py script to update file_path_tree.txt.
    """
    print(f"Attempting to update '{FILE_TREE_TXT_NAME}' by running '{FILE_TREE_SCRIPT_NAME}'...")
    if not os.path.exists(FILE_TREE_SCRIPT_ABS_PATH):
        print(f"Error: File tree script '{FILE_TREE_SCRIPT_ABS_PATH}' not found.", file=sys.stderr)
        return False
    
    try:
        # Ensure create_path_tree.py is executable or called with python interpreter
        # For simplicity, calling with python3 assuming it's in PATH
        process = subprocess.run(
            [sys.executable, FILE_TREE_SCRIPT_ABS_PATH],
            capture_output=True,
            text=True,
            check=True, # Raises CalledProcessError for non-zero exit codes
            cwd=PROJECT_ROOT_ABS_PATH # Run from project root, if script expects that
        )
        print(f"'{FILE_TREE_SCRIPT_NAME}' output: {process.stdout.strip()}")
        if process.stderr:
            print(f"'{FILE_TREE_SCRIPT_NAME}' error output: {process.stderr.strip()}", file=sys.stderr)
        print(f"'{FILE_TREE_TXT_NAME}' updated successfully.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error running '{FILE_TREE_SCRIPT_NAME}': {e}", file=sys.stderr)
        print(f"Stdout: {e.stdout}", file=sys.stderr)
        print(f"Stderr: {e.stderr}", file=sys.stderr)
        return False
    except FileNotFoundError:
        print(f"Error: Python interpreter '{sys.executable}' or script '{FILE_TREE_SCRIPT_ABS_PATH}' not found.", file=sys.stderr)
        return False

def get_relative_path(file_abs_path, root_abs_path):
    """Computes the relative path of a file with respect to the root, using forward slashes."""
    rel_path = os.path.relpath(file_abs_path, root_abs_path)
    return rel_path.replace(os.sep, '/')

def main():
    """
    Main function to concatenate files.
    """
    print(f"Starting concatenation process.")
    print(f"Project Root: {PROJECT_ROOT_ABS_PATH}")
    print(f"Output File: {OUTPUT_FILE_ABS_PATH}")

    # 1. Update file_path_tree.txt
    if not update_file_tree():
        print(f"Could not update '{FILE_TREE_TXT_NAME}'. Proceeding without it or with existing one if present.", file=sys.stderr)
        # Decide if this is a fatal error or if we can proceed
        # For now, let's try to proceed and see if the file exists anyway

    # 2. Read the content of the updated file_path_tree.txt
    file_tree_content = []
    try:
        with open(FILE_TREE_TXT_ABS_PATH, 'r', encoding='utf-8') as f_tree:
            file_tree_content = f_tree.readlines()
        print(f"Successfully read '{FILE_TREE_TXT_ABS_PATH}'.")
    except FileNotFoundError:
        print(f"Warning: '{FILE_TREE_TXT_ABS_PATH}' not found after attempting update. File tree will not be included.", file=sys.stderr)
    except Exception as e:
        print(f"Error reading '{FILE_TREE_TXT_ABS_PATH}': {e}", file=sys.stderr)
        # Not including file tree if error

    # 3. Start the concatenated_code.py file
    try:
        with open(OUTPUT_FILE_ABS_PATH, 'w', encoding='utf-8') as f_out:
            print(f"Opened '{OUTPUT_FILE_ABS_PATH}' for writing.")
            f_out.write(f'"""Path: {OUTPUT_FILENAME}."""\n') # Add path comment to the concatenated file itself
            f_out.write("# Concatenated Python files from the project.\n")
            f_out.write(f"# Generated by: {os.path.basename(__file__)}\n")
            f_out.write("# Project Root: " + PROJECT_ROOT_NAME + "\n\n")


            # Add file tree if available
            if file_tree_content:
                f_out.write("# --- Project File Tree ---\n")
                for line in file_tree_content:
                    f_out.write(f"# {line.rstrip()}\n") # Comment out each line
                f_out.write("# --- End File Tree ---\n\n\n")
            else:
                f_out.write("# --- File tree not available or not generated. ---\n\n\n")

            # 4. Iterate through the specified directories
            found_py_files = False
            for scan_dir_abs in DIRS_TO_SCAN_ABS:
                scan_dir_relative = get_relative_path(scan_dir_abs, PROJECT_ROOT_ABS_PATH)
                print(f"Scanning directory: '{scan_dir_relative}'")
                if not os.path.exists(scan_dir_abs):
                    print(f"Warning: Directory '{scan_dir_relative}' does not exist. Skipping.", file=sys.stderr)
                    continue

                for root, _, files in os.walk(scan_dir_abs):
                    for file_name in sorted(files): # Sort files for consistent order
                        if file_name.endswith(".py"):
                            found_py_files = True
                            file_abs_path = os.path.join(root, file_name)
                            relative_file_path = get_relative_path(file_abs_path, PROJECT_ROOT_ABS_PATH)
                            
                            print(f"  Processing file: '{relative_file_path}'")

                            f_out.write(f"# --- Start of file: {relative_file_path} ---\n")
                            try:
                                with open(file_abs_path, 'r', encoding='utf-8') as f_in:
                                    f_out.write(f_in.read())
                                f_out.write("\n") # Ensure a newline after file content
                            except Exception as e:
                                f_out.write(f"# Error reading file {relative_file_path}: {e}\n")
                                print(f"Error reading file {relative_file_path}: {e}", file=sys.stderr)
                            
                            f_out.write(f"# --- End of file: {relative_file_path} ---\n\n\n")
            
            if not found_py_files:
                print("No .py files found in the specified directories to concatenate.")
                f_out.write("# No .py files found in specified directories (src/, utils/).\n")

        print(f"Successfully created '{OUTPUT_FILE_ABS_PATH}'.")

    except Exception as e:
        print(f"Error writing to output file '{OUTPUT_FILE_ABS_PATH}': {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
